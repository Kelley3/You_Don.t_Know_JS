
> # 作用域是什么

* [传统编译语言的流程](#传统编译语言的流程)
* [理解作用域](#理解作用域)
* [作用域嵌套](#作用域嵌套)
* [异常](#异常)
* [变量赋值](#变量赋值)

### 传统编译语言的流程
`词发分析`
* 将字符组成的字符串分解成有意义的代码块，这些代码块被称为`词法单元`
* 例如 `var a = 2;`会被分解成以下词法单元`var, a, =, 2, ;`
* `空格`是否会被当作词法单元，取决于空格在这门语言中是否具有意义

`语法分析`
* 将`词法单元流`（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树，即`抽象语法树`

`代码生成`
* 将`抽象语法树`转换成`可执行代码`，这个过程跟语言，目标平台等息息相关

### 理解作用域
`引擎`
* 从头到尾负责整个 JavaScript 程序的`编译`及`执行`过程

`编译器`
* 负责`语法分析`及`代码生成`等脏活累活

`作用域`
* 定义了一套`规则`，用于确定在何处以及如何`查找变量`（标识符）
* 如果查找的目的是对变量进行赋值，则进行`LHS`查询，如果是获取变量的值，则进行`RHS`查询

```JavaScript
function foo(a) {
  var b = a;
  return a + b;
}
var c = foo(2);

// LHS 查询：3处
// c = .., a = 2（隐式变量分配）,b = ..
// RHS 查询：4处
// foo(2.., = a, a.., ..b
```

### 作用域嵌套
* 当一个块或函数嵌套在另一个块或函数时，就发生了作用域的`嵌套`
* `LHS`和`RHS`查询都会在`当前执行作用域`中开始，如果当前作用域无法找到该变量，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量或抵达`全局作用域`为止

### 异常
* 不成功的`RHS`引用会导致抛出`ReferenceError`异常，不成功的`LHS`引用会导致自动隐式地创建一个全局变量（`非严格模式下`），或者抛出`ReferenceError`异常（`严格模式下`）
* `RHS`查询找到一个变量，但如果对变量进行不合理的操作则会抛出`TypeError`异常

### 变量赋值
* 首先`编译器`在代码执行前在当前作用域中声明一个新变量
* 然后在运行时`引擎`会在作用域中查找（`LHS`）该变量，如果能找到就对其进行赋值
